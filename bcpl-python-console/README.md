# BCPL Python Console

This is a pure Python port of the BCPL INTCODE interpreter (`icint.c`).
It allows compiling and running BCPL programs in a Python environment.

Ported from the Node.js version, see the `bcpl-js-console` directory.  
More or less compatible with the classic book https://archive.org/details/richards1979bcpl/mode/2up

## Performance Note

This pure Python implementation works well for typical BCPL programs and compilation tasks.
While CPython is adequate for most uses, you can optionally use PyPy for even better performance:

```bash
# Using CPython (standard Python)
./compile.sh test.b
./compile.sh test.b -iINPUT -oOUTPUT

# Using PyPy for better performance (optional)
PYTHON=pypy3 ./compile.sh test.b
PYTHON=pypy3 ./compile.sh test.b -iINPUT -oOUTPUT
```

## Requirements

- Recommend Python 3.6 or later (PyPy 3.6+ recommended for better performance)
- No external dependencies (pure Python implementation)

## Files

- `icint.py`: The main interpreter and assembler (ported from `icint.c` / `icint.js`).
- `syni`: The syntax analyzer (INTCODE).
- `trni`: The translator (INTCODE).
- `cgi`: The code generator (INTCODE).
- `libhdr`: The standard library header.
- `test.b`: A sample BCPL program.
- `fact.b`: Factorial example.
- `queens.b`: N-Queens solver example.
- `cmpltest.b`: Compiler test suite.

## Source Code and Generated Files

### Source Code
The source code for your program is a `.b` file (e.g., `test.b`). You can create your own BCPL files in this directory.
- **Input**: `filename.b` (Your BCPL source code)
- **Library**: `libhdr` (Standard library header, usually included via `GET "LIBHDR"`)

### Generated Files
The compilation process generates the following intermediate and final files in the current directory:

1. **`OCODE`**: Intermediate code generated by the first pass (`syni` + `trni`).
   - *Note*: The compiler writes specifically to a file named `OCODE` in the current working directory.
2. **`INTCODE`**: The final executable bytecode generated by the code generator (`cgi`).
   - *Note*: This is the output of the `cgi` pass, which we capture from stdout or file output.

## Usage

### Automated Compilation and Execution

**On Linux/macOS**, use the `compile.sh` script:

```bash
./compile.sh test.b
./compile.sh test.b -iINPUT -oOUTPUT
```

**On Windows**, use the `compile.bat` script:

```cmd
compile.bat test.b
compile.bat test.b -iINPUT -oOUTPUT
```

### Manual Steps

1. **Prepare the compiler:**
   Concatenate `syni` and `trni` to create `synitrni`.
   ```bash
   cat syni trni > synitrni
   ```

2. **Compile BCPL to OCODE:**
   ```bash
   python3 icint.py synitrni -itest.b
   ```
   This produces an `OCODE` file.

3. **Compile OCODE to INTCODE:**
   ```bash
   python3 icint.py cgi -iOCODE
   ```
   This produces an `INTCODE` file.

4. **Run INTCODE:**
   ```bash
   python3 icint.py INTCODE
   python3 icint.py INTCODE -iINPUT -oOUTPUT
   ```

## Implementation Details

- The interpreter uses 16-bit signed arithmetic to match the original C implementation.
- `syni` and `trni` are concatenated to share the label namespace (or rather, to avoid clearing labels between passes, although they mostly use globals).
- `trni` writes directly to a file named `OCODE` (ignoring standard output redirection for the code itself).
- Pure Python implementation with no external dependencies.

## Differences from Node.js Version

This Python port is functionally equivalent to the Node.js version (`icint.js`) with the following implementation details:
- Uses a plain Python list for memory instead of `ArrayBuffer`/`Int16Array`
- 16-bit signed values are emulated by masking and sign-extending as needed
- Uses standard Python file I/O instead of Node.js `fs` module
- All 16-bit signed/unsigned arithmetic is carefully emulated
